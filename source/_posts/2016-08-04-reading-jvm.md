---
title: 《深入理解Java虚拟机》笔记
date: 2016-08-04 00:38:38
tags:
  - 讀書筆記
  - Java
---

> 筆記只有Java內存和虛擬機兩部分，準備面試時記的。
> 參考的書是《深入理解Java虛擬機》，[京東鏈接](https://item.jd.com/1069428318.html)。

## 1. Java内存区域与内存溢出异常

### 1.1 运行时数据区域
![Alt text](http://7b1fa0.com1.z0.glb.clouddn.com/2614605-246286b040ad10c1.png)

### 1.2 程序计数器
- 可以看做当前线程所执行的字节码的行号指示器
- 如果是Native方法，计数器为空

### 1.3 虚拟机栈
- 每个方法在执行的时候都会创建一个`栈帧`
	- 存储局部变量表，操作数栈，动态链接，方法出口等
- 局部变量表所需的内存空间在编译期间就完成分配确定
- 当线程请求额栈深度大于虚拟机规定的栈深度时，抛出StackOverflowError异常
- 如果虚拟机栈可以动态扩展，当无法申请到足够的内存时，抛出OutOfMemoryErrory异常

<!-- more -->

### 1.4 本地方法栈
- 和虚拟机栈类似
- 只不过是为虚拟机执行Native方法服务
- 有些虚拟机把虚拟机栈和本地方法栈合二为一，比如Sun  HotSpot虚拟机

### 1.5 Java堆
- 所有的对象实例和数组都在堆上分配内存
- 是垃圾收集器管理的主要区域，所以常被称为`GC堆`
- 现在收集器一般采用分代收集算法，故Java堆中可以细分：新生代和老年代
- -Xmx和-Xms控制堆大小

### 1.6 方法区
- 存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码和数据
- 很多人把它称为`永久代`
	- 主要是有虚拟机把GC分代收集拓展到了方法区
- `运行时常量池`
	- Runtime Constant Pool
	- Class文件除了有类的版本，字段，方法，接口等信息外，还有常量池
	- 存储编译期生成的各种字面量和符号引用
	- 具有`动态性`，不一定在编译期才能产生
		- String类的intern()方法？
### 1.7 直接内存
- Direct Memory
- 不是Java虚拟机规范中定义的内存区域
- JDK 1.4以后新加入的NIO(New Input/Ouput)，引入一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存
- 通过在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作
- 可以提高性能，避免了从Java堆和Native堆中来回复制数据

### 1.8 对象的创建(new)

1. 在常量池中定位到一个类的符号引用
9. 检查这个符号对应的类是否被加载，解析和初始化过，没有的话必须先加载类
10. 为新生对象分配内存
	- 指针碰撞（Bump the Pointer）
		- Java堆中的内存是绝对规整的
		- 用指针来区分对象区和空闲区
	- 空闲列表（Free List）
		- 内存不规整
	- 内存是否规整与所采用的垃圾收集器是否有压缩整理功能决定
        - Serial, ParNew等带Compact guo过程的收集器采用指针碰撞
        - CMS这种基于Mark-Sweep算法的收集器，采用空闲列表
   11. 内存分配操作需要线程安全
  - 方法一： 采用CAS+失败重试的方式
  - 方法二：每个线程在Java堆中预分配一小块内存区域，作为本地线程分配缓冲（Thread Local Alllocation Buffer, TLAB）
	  -  只有当TLAB分配完时，才需要同步锁定
12. 初始化内存空间为零值，不包括对象头
13. 虚拟机对对象进行设置
	- 确定是哪个类的实例，如何找到类的元数据信息，对象的哈希吗，GC分代年龄等信息
14. 执行对象的初始化方法
	- 构造器等，按照程序员的意愿初始化

### 1.9 对象的内存布局
- 3个区域：对象头 Header, 实例数据 Instance Data, 对齐填充 Padding
- 对象头
	- Mark Word: 哈希吗，GC分代年龄，锁状态标示，线程持有的锁，偏向线程ID，偏向时间戳等
		- 32位或64位，看机器
	- 类型指针
	- 如果是数组，还有记录数组长度的数据
- 实例数据
	- 按照一定的分配策略分配实例数据
	- 基本上相同宽度的字段会分配到一起
	- 也有可能插入小宽度的字段
- 对齐
	- HotSpot 8字节对齐

### 1.10 对象的访问定位
- 句柄访问
	- 通过句柄再去访问实例数据
- 直接指针访问


## 2. 垃圾收集器和内存分配策略

### 2.1. 哪些对象需要回收？

#### 引用计数法
- 每个对象添加一个引用计数器，有一个地方引用时加1，引用失效时减1
- 引用计数器为0的对象不再被使用
- 判定的效果高
- 但是很少主流的Java虚拟机使用
	- 很难解决相互循环引用的问题
- 四种引用类型
	- 强引用 Strong Reference
		- 类似 Object o = new Object()
		- 只要有强引用，就不会回收
	- 软引用 Soft Reference
		- 将要发生内存溢出异常之前，才会把这些对象列进回收范围进行第二次回收
	- 弱引用 Weak Reference
		- 弱一点，只能生存到下一次垃圾收集发生之前
		- 相当于多了一次机会
	- 虚引用 Phantom Reference
		- 唯一的目的是在回收时受到一个系统通知

#### 可达性分析算法
- Reachability analysis
- 通过GC Roots作为起点
- 向下搜索，所走过的路径成为引用链（Reference Chain）
- 当一个对象到GC Roots没有任何引用链相连时，对象不可达
- 几种GC Roots对象
	- 虚拟机栈（栈帧中的本地变量表）中引用的对象
	- 方法区中类静态属性引用的对象
	- 方法区中常量引用的对象
	- 本地方法栈中JNI（Native方法）引用的对象
- 对象是否已死？
	- 一个对象不可达时，也不是非死不可
	- 要经过两次标记过程
		- 第一次标记
			- 对象不可达时
			- 筛选的条件是是否有必要执行finalize()方法
				- 对象没有覆盖finalize()方法
				- finalize()方法被执行过
		- 第二次标记
			- 如果有必要执行finalize()方法
			- 进入F-Queue，由低优先级的Finalizer线程执行
			- 会触发finalize方法，但不保证等待它运行结束
			- finalize方法是对象逃离死亡的最后机会
				- 加上引用可以回到引用链上
			- 第二次标记发现可达的对象，会复活
		- finalize()方法只会被调用一次，复活之后是不会再次调用这个方法的
- 回收方法区
	- Hotspot中的永久代
	- 很多人认为不需要垃圾收集
	- 垃圾收集的效率低，回收的空间少
	- 永久代的垃圾收集主要收集两部分内容
		- 废弃常量
		- 无用的类

### 2.2 垃圾收集算法

#### 标记-清除算法

- Mark-Sweep
- 分标记和清除两个阶段
- 不足
	- 效率问题：两个过程的效率都不高
	- 空间问题：会产生大量的内存碎片

#### 复制算法

- 讲可用内存分为两块，每次使用其中的一块
- 当一块内存用完了，将存活的对象复制到另一块内存中
- 再把已使用过的内存空间一次性清理
- 优点
	- 实现简单
	- 运行效率高
- 缺点
	- 浪费了一半的内存
- 改进
	- 现在很多商用虚拟机使用复制算法来回收新生代
	- IBM研究发现98%的新生代对象都是死的很快
	- 将内存分为一块较大的Eden空间和两块Survivor空间
	- 每次使用Eden空间和Survivor空间
	- 回收时，把Eden和Survivor中存活的对象复制到另一块Survivor中
	- 最后清理掉使用过的Eden和Survivor空间
	- HotSpot虚拟机默认的Eden和Survivor大小比例是8：1
		- 新生代可用内存为整个新生代容量的90%
	- 当Survivor空间不够时，需要依赖其他内存（老年代）进行分配担保（Handle Promotion），直接进入老年代

#### 标记-整理算法

- Mark-Compact
- 根据老年代的特点可以使用这种算法
- 整理过程
	- 不直接清理
	- 所有存活的对象向一端移动
	- 清理掉边界以外的内存

#### 分代收集算法

- 现代很多商业虚拟机使用这个方法
- 讲Java堆分为新生代和老年代区域，根据年代特点选择不同的收集算法
- 新生代：复制
- 老年代：标记-清除 或者 标记-整理


### 2.3 垃圾收集器

#### Serial收集器

- 单线程
- 采用复制算法
- 进行垃圾收集时必须暂停其他所有的工作线程
	- stop the world
- 在Client模式下的虚拟机来说是一个很好的选择

#### ParNew收集器

- Serial的多线程版本
- 采用复制算法
- Server模式下的迅疾首选的新生代收集器
- 能够和CMS收集器配合工作

#### Parallel Scavenge收集器

- 新生代收集器
- 采用复制算法
- 目标是达到一个可控的吞吐量
	- CPU用于运行用户代码的时间与总消耗时间的比值
	- 而不是尽可能缩短垃圾收集时用户线程的停顿时间

#### Serial Old收集器

- Serial的老年代版本，也是单线程
- 使用的是标记-整理算法

#### Parallel Old收集器

- Parallel Scavenge的老年代版本
- 使用的是标记-整理算法

#### CMS收集器
- Concurrent Mark Sweep
- 目的：获得最短回收停顿时间
- B/S服务器端的虚拟机多采用
- 采用标记-清除算法
- 四个步骤
	- 初始标记 (initial mark)
	- 并发标记 concurrent mark
	- 重新标记 remark
	- 并发清除 concurrent sweep
	- 其中初始标记和重新标记需要stop the world

#### G1收集器

- 目前最前沿成果之一
- 面向服务端应用
- 几个特点
	- 并发与并行
	- 分代收集
	- 空间整理
	- 可预测的停顿
- 四个步骤
	- 初始标记 initial marking
	- 并发标记  concorrent marking
	- 最终标记 final marking
	- 筛选回收 live data counting and evacuation

### 2.4 内存分配与回收策略

- 兑现主要分配在新生代的Eden区
- 如果启用了本地线程分配缓冲，按线程首先分配在TLAB上
- 少数情况下也会直接分配在老年代
- 大对象直接进入老年代
	- 需要大量的连续内存空间
	- 很长的字符串和数组
- 长期存活的对象进入老年代
	- 每一个对象有年龄（age）计数器
	- 每次被复制到Survivor区域，年龄加1岁
	- 当年龄达到一定程度（默认为15岁，MaxTenuringThreshold），会被晋升到老年代
- 动态对象年龄判定
	- 不一定要达到年龄才能进入老年代
	- 当Survivor空间中相同年龄的所有对象大小之和超过Survivor空间的一半
	- 则大于等于该年龄的对象可以直接进去老年代
- 空间担保分配
	- 新生代采用复制算法
	- 如果Survivor空间无法容纳的对象直接进入老年代
